#!/usr/bin/env python
import sys
import os
import tempfile
from os import symlink
from docker import Client
import subprocess
import fcntl
import shutil
import json
import re

fdnull = open(os.devnull, 'w')

systems = {
    'grace':  {
        'host': '128.55.34.74',
        'path': '/scratch/scratchdirs/craydock/docker',
        'rsyncOptions': ['-e', 'ssh -o StrictHostKeyChecking=no -l craydock -i /home/docker/craydock.id_dsa'],
    }
}

c = Client(base_url='unix://var/run/docker.sock')

imagePath = "/export/data/dockergw/images"

def lookup(name, username, password):
    lst = c.images()
    image = None
    for i in lst:
        for tag in i['RepoTags']:
            if tag==name:
                image=i
    return image

def lockfile(fname):
    fd = open(fname, 'w')
    try:
        fcntl.lockf(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
    except IOError:
        fd.close()
        return None
    return fd

def get_size(start_path):
    total_size = 0
    for dirpath, dirnames, filenames in os.walk(start_path):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            total_size += os.path.getsize(fp)
    return total_size

def expandDockerLayer(layersPath, id, mntPoint):
    jsonPath = os.path.join(layersPath, id, "json")
    if os.path.exists(jsonPath):
         json_data = open(jsonPath, 'r')
         data = json.load(json_data)
         json_data.close()
         if 'parent' in data:
             expandDockerLayer(layersPath, data['parent'], mntPoint)
    tarPath = os.path.join(layersPath, id, "layer.tar")
    ret = subprocess.call(['tar', 'xf', tarPath, '-C', mntPoint], stdout=fdnull, stderr=fdnull)

def generateExt4Image(id, layersPath):
    global imagePath
    ## create sparsefile for the image
    imageTempPath = os.path.join(imagePath, id + ".ext4_partial")
    ret = subprocess.call(["dd", "of=%s" % imageTempPath, "bs=1", "count=0", "seek=%d" % (get_size(layersPath) * 2)], stdout=fdnull, stderr=fdnull)
    if ret != 0:
        # error handling
        pass
    ret = subprocess.call(["mke2fs", "-F", imageTempPath], stdout=fdnull, stderr=fdnull)
    if ret != 0:
        # error handling
        pass
    
    ## prepare a mount point and mount the image file
    mntPoint = tempfile.mkdtemp()
    ret = subprocess.call(["mount", "-o", "loop", imageTempPath, mntPoint], stdout=fdnull, stderr=fdnull)
    if ret != 0:
        return None

    expandDockerLayer(layersPath, id, mntPoint)

    loopDevice = None
    fd = open("/proc/mounts", "r")
    for line in fd:
        (device, t_mntPoint, stuff) = line.split(' ', 2)
        if t_mntPoint == mntPoint and re.match('/dev/loop\d+', device) is not None:
            loopDevice = device
            break
    fd.close()
    ret = subprocess.call(["umount", mntPoint], stdout=fdnull, stderr=fdnull)
    if loopDevice is not None:
        subprocess.call(['losetup', '-d', loopDevice])
    return imageTempPath

def generateCramFSImage(id, layersPath):
    global imagePath
    imageTempPath = os.path.join(imagePath, id + ".cram_partial")
    expandedPath = os.path.join(imagePath, id + ".expanded")
    os.mkdir(expandedPath)
    expandDockerLayer(layersPath, id, expandedPath)
    
    ret = subprocess.call(["mkfs.cramfs", expandedPath, imageTempPath], stdout=fdnull, stderr=fdnull)
    if ret != 0:
        # error handling
        pass
    
    return imageTempPath

def package(name, id):
    global imagePath
    global c
    returnValue = None
    finalPath = os.path.join(imagePath, id + ".ext4")
    tarPath = os.path.join(imagePath, id + ".tar")
    if os.path.exists(finalPath):
        return finalPath

    lockPath = os.path.join(imagePath, id + ".lock")
    lfd = lockfile(lockPath)
    if lfd is None:
        return None

    ## get the tarball
    if os.path.exists(tarPath):
        os.unlink(tarPath)

    ret = 1
    try:
        ret = subprocess.call(['docker','save','-o',tarPath,name], stdout=fdnull, stderr=fdnull)
    finally:
        if ret != 0 and os.path.exists(tarPath):
            os.unlink(tarPath)
            return None

    ## expand the tar file
    layersPath = os.path.join(imagePath, id + ".layers")
    ret = 1
    try:
        os.mkdir(layersPath)
        ret = subprocess.call(['tar', 'xf', tarPath, '-C', layersPath], stdout=fdnull, stderr=fdnull)
    finally:
        if ret != 0 and os.path.exists(layersPath):
            shutil.rmtree(layersPath)
            return None

    imageTempPath = generateExt4Image(id, layersPath)
    if imageTempPath is not None:
        shutil.move(imageTempPath, finalPath)
        returnValue = finalPath
       
    shutil.rmtree(layersPath)
    os.unlink(tarPath)
    lfd.close()
    os.unlink(lockPath) 
    return returnValue


def rsync(filename,system):
    (basePath,imageFilename) = os.path.split(filename)
    remoteFilename = os.path.join(systems[system]['path'], imageFilename)
    rsyncCmd = ['rsync', '-aS']
    if 'rsyncOptions' in systems[system]:
        rsyncCmd.extend(systems[system]['rsyncOptions'])
    rsyncCmd.extend([filename,'%s:%s' % (systems[system]['host'], remoteFilename)])
    ret = subprocess.call(rsyncCmd, stdout=fdnull, stderr=fdnull)
    return ret == 0


def main():
    input_data=sys.stdin.readline().strip().split(' ')
    if input_data is None or type(input_data) is not list or len(input_data) < 2:
        print "ERR"
        sys.exit(0)

    name = input_data[0]
    system = input_data[1]
    if system not in systems:
        print "ERR: unknown system"
        sys.exit(0)

    registry = 'https://index.docker.io/v1/'
    username = None
    password = None
    logged_in = False
    for arg in input_data[2:]:
        (k,v) = arg.split('=', 2)
        if k == "username":
            username = v
        if k == "password":
            password = v
        if k == "registry":
            registry = v
    if username is not None and password is not None:
        val = c.login(username=username, password=password, registry=registry)
        logged_in = True
    image = lookup(name, username, password)
    if image is None:
        c.pull(name)
        image = lookup(name, username, password)
    if image is None:
        print "ERR"
        sys.exit(0)
    if type(image) is not dict or 'Id' not in image:
        print 'ERR'
        sys.exit(0)
    id = image['Id']

    path = package(name, id)
    if path is not None and rsync(path,system):
        print id
        sys.exit(0)
    print "ERR"
    sys.exit(0)


if __name__ == "__main__":
    main()
