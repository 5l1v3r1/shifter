#!/usr/bin/env python
import sys
import os
import tempfile
from os import symlink
from docker import Client
import subprocess
import fcntl
import shutil
import json
import re

fdnull = open(os.devnull, 'w')

systems = {
    'grace':  {
        'host': '128.55.34.74',
        'path': '/scratch/scratchdirs/craydock/docker',
        'rsyncOptions': ['-e', 'ssh -o StrictHostKeyChecking=no -l craydock -i /home/docker/craydock.id_dsa'],
        'sshOptions': ['-o','StrictHostKeyChecking=no','-l','craydock','-i','/home/docker/craydock.id_dsa'],
    },
    'alva':  {
        'host': 'alvamom1',
        'path': '/scratch1/scratchdirs/craydock/docker',
        'rsyncOptions': ['-e', 'ssh -o StrictHostKeyChecking=no -l craydock -i /home/docker/craydock.id_dsa'],
        'sshOptions': ['-o','StrictHostKeyChecking=no','-l','craydock','-i','/home/docker/craydock.id_dsa'],
    },
    'edison':  {
        'host': 'edison04-eth4',
        'path': '/scratch2/scratchdirs/craydock/docker',
        'rsyncOptions': ['-e', 'ssh -o StrictHostKeyChecking=no -l craydock -i /home/docker/craydock.id_dsa'],
        'sshOptions': ['-o','StrictHostKeyChecking=no','-l','craydock','-i','/home/docker/craydock.id_dsa'],
    },
}

c = Client(base_url='unix://var/run/docker.sock')

imagePath = "/export/data/dockergw/images"

def lookup(name, username, password):
    lst = c.images()
    image = None
    for i in lst:
        for tag in i['RepoTags']:
            if tag==name:
                image=i
    return image

def lockfile(fname):
    fd = open(fname, 'w')
    try:
        fcntl.lockf(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
    except IOError:
        fd.close()
        return None
    return fd

def get_size(start_path):
    total_size = 0
    for dirpath, dirnames, filenames in os.walk(start_path):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            total_size += os.path.getsize(fp)
    return total_size

def extractDockerMetadata(layersPath, id):
    jsonPath = os.path.join(layersPath, id, "json")
    if os.path.exists(jsonPath):
        json_data = open(jsonPath, 'r')
        data = json.load(json_data)
        json_data.close()
        return data
    return None

def expandDockerLayer(layersPath, id, mntPoint):
    jsonPath = os.path.join(layersPath, id, "json")
    if os.path.exists(jsonPath):
         json_data = open(jsonPath, 'r')
         data = json.load(json_data)
         json_data.close()
         if 'parent' in data:
             expandDockerLayer(layersPath, data['parent'], mntPoint)
    tarPath = os.path.join(layersPath, id, "layer.tar")
    ret = subprocess.call(['tar', 'xf', tarPath, '-C', mntPoint], stdout=fdnull, stderr=fdnull)

def generateExt4Image(id, layersPath):
    global imagePath
    ## create sparsefile for the image
    imageTempPath = os.path.join(imagePath, id + ".ext4_partial")
    ret = subprocess.call(["dd", "of=%s" % imageTempPath, "bs=1", "count=0", "seek=%d" % (get_size(layersPath) * 2)], stdout=fdnull, stderr=fdnull)
    if ret != 0:
        # error handling
        pass
    ret = subprocess.call(["mke2fs", "-F", imageTempPath], stdout=fdnull, stderr=fdnull)
    if ret != 0:
        # error handling
        pass
    
    ## prepare a mount point and mount the image file
    mntPoint = tempfile.mkdtemp()
    ret = subprocess.call(["mount", "-o", "loop", imageTempPath, mntPoint], stdout=fdnull, stderr=fdnull)
    if ret != 0:
        return None

    expandDockerLayer(layersPath, id, mntPoint)

    loopDevice = None
    fd = open("/proc/mounts", "r")
    for line in fd:
        (device, t_mntPoint, stuff) = line.split(' ', 2)
        if t_mntPoint == mntPoint and re.match('/dev/loop\d+', device) is not None:
            loopDevice = device
            break
    fd.close()
    ret = subprocess.call(["umount", mntPoint], stdout=fdnull, stderr=fdnull)
    if loopDevice is not None:
        subprocess.call(['losetup', '-d', loopDevice])
    return imageTempPath

def generateCramFSImage(id, layersPath):
    global imagePath
    imageTempPath = os.path.join(imagePath, id + ".cram_partial")
    expandedPath = os.path.join(imagePath, id + ".expanded")
    os.mkdir(expandedPath)
    expandDockerLayer(layersPath, id, expandedPath)
    
    ret = subprocess.call(["mkfs.cramfs", expandedPath, imageTempPath], stdout=fdnull, stderr=fdnull)
    if ret != 0:
        # error handling
        pass
    
    return imageTempPath

def generateSquashFSImage(id, layersPath):
    global imagePath
    imageTempPath = os.path.join(imagePath, id + ".squash_partial")
    expandedPath = os.path.join(imagePath, id + ".expanded")
    os.mkdir(expandedPath)
    expandDockerLayer(layersPath, id, expandedPath)

    ret = subprocess.call(["mksquashfs", expandedPath, imageTempPath, "-all-root"])
    if ret != 0:
        # error handling
        pass

    return imageTempPath

def getmetadata(name, id):
    metadataPath=os.path.join(imagePath, id + ".json")
    if os.path.exists(metadataPath):
        fd = open(metadataPath, 'r')
        outdata = {}
        data = json.load(fd)
        fd.close()
        if 'config' in data:
            if 'Env' in data['config'] and data['config']['Env'] is not None:
                for envItem in data['config']['Env']:
                    if 'env' not in outdata:
                        outdata['env'] = []
                    outdata['env'].append(envItem)
            if 'Entrypoint' in data['config']:
                entry = data['config']['Entrypoint']
                if type(entry) is list:
                    entry = ' '.join(entry)
                outdata['entry'] = entry
        return outdata
    return None
        
def package(name, id, format="ext4"):
    global imagePath
    global c
    returnValue = None
    finalPath = os.path.join(imagePath, id + ".%s" % format)
    tarPath = os.path.join(imagePath, id + ".tar")
    jsonPath = os.path.join(imagePath, id + ".json")
    metadataPath = os.path.join(imagePath, id + ".meta")
    if os.path.exists(finalPath) and os.path.exists(jsonPath) and os.path.exists(metadataPath):
        return (finalPath,jsonPath,metadataPath)

    lockPath = os.path.join(imagePath, id + ".lock")
    lfd = lockfile(lockPath)
    if lfd is None:
        return (None,None,None)

    ## get the tarball
    if os.path.exists(tarPath):
        os.unlink(tarPath)

    ret = 1
    try:
        ret = subprocess.call(['docker','save','-o',tarPath,name], stdout=fdnull, stderr=fdnull)
    finally:
        if ret != 0 and os.path.exists(tarPath):
            os.unlink(tarPath)
            return (None,None,None)

    ## expand the tar file
    layersPath = os.path.join(imagePath, id + ".layers")
    if os.path.exists(layersPath):
        shutil.rmtree(layersPath)
    ret = 1
    try:
        os.mkdir(layersPath)
        ret = subprocess.call(['tar', 'xf', tarPath, '-C', layersPath], stdout=fdnull, stderr=fdnull)
    finally:
        if ret != 0 and os.path.exists(layersPath):
            shutil.rmtree(layersPath)
            return (None,None,None)

    if not os.path.exists(jsonPath):
    	imageMetadata = extractDockerMetadata(layersPath, id)
        fd = open(jsonPath, 'w')
        json.dump(imageMetadata, fd)
        fd.close()

    if not os.path.exists(metadataPath):
        metadata = getmetadata(name, id)
        if metadata is not None:
            fd = open(metadataPath, 'w')
            if 'env' in metadata:
                for item in metadata['env']:
                    fd.write("ENV: %s\n" % item)
            if 'entry' in metadata and metadata['entry'] is not None:
                fd.write("ENTRY: %s\n" % metadata['entry'])
            fd.close()
    
    if not os.path.exists(finalPath):
        if format == "ext4":
            imageTempPath = generateExt4Image(id, layersPath)
        elif format == "squashfs":
            imageTempPath = generateSquashFSImage(id, layersPath)
        if imageTempPath is not None:
            shutil.move(imageTempPath, finalPath)
            returnValue = finalPath
       
    shutil.rmtree(layersPath)
    os.unlink(tarPath)
    lfd.close()
    os.unlink(lockPath) 
    return (returnValue,jsonPath,metadataPath)


def rsync(filename,system):
    (basePath,imageFilename) = os.path.split(filename)
    remoteFilename = os.path.join(systems[system]['path'], imageFilename)
    # test to see if the file is reasonably likely to already be there
    if 1==0:
	    statCmd = ['stat', '-t', filename]
	    proc = subprocess.Popen(statCmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
	    (stdout,stderr) = proc.communicate()
	    if proc.returncode != 0:
		return False
	    statData = stdout.strip().split(' ')
	    sshCmd = ['ssh'] 
	    if 'sshOptions' in systems[system]:
		sshCmd.extend(systems[system]['sshOptions'])
		sshCmd.extend([systems[system]['host'], 'stat', '-t', remoteFilename])
		proc = subprocess.Popen(sshCmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
		(stdout,stderr) = proc.communicate()
		if proc.returncode == 0:
		    data = stdout.strip().split(" ")
		    if statData[1] == data[1]:
			return True
        
    rsyncCmd = ['rsync', '-aS']
    if 'rsyncOptions' in systems[system]:
        rsyncCmd.extend(systems[system]['rsyncOptions'])
    rsyncCmd.extend([filename,'%s:%s' % (systems[system]['host'], remoteFilename)])
    ret = subprocess.call(rsyncCmd, stdout=fdnull, stderr=fdnull)
    return ret == 0


def main():
    verbose=True
    input_data=sys.stdin.readline().strip().split(' ')
    if input_data is None or type(input_data) is not list or len(input_data) < 2:
        print "ERR: Bad Input"
        sys.exit(0)

    name = input_data[0]
    system = input_data[1]
    if system not in systems:
        print "ERR: unknown system"
        sys.exit(0)

    mode="default"
    registry = 'https://index.docker.io/v1/'
    username = None
    password = None
    logged_in = False
    format = "ext4"
    for arg in input_data[2:]:
        (k,v) = arg.split('=', 2)
        if k == "username":
            username = v
        if k == "password":
            password = v
        if k == "registry":
            registry = v
        if k == "mode":
            mode=v
        if k == "format":
            format=v
    if username is not None and password is not None:
        val = c.login(username=username, password=password, registry=registry)
        logged_in = True
    if mode not in ['default','images','nopull','gopull']:
        print "ERR: invalid mode"
        sys.exit(0)
    if mode == 'images':
        images = c.images()
        for image in images:
            if 'RepoTags' in image:
                for tag in image['RepoTags']:
                    print "IMAGE: %s,%s,%s,%s" % (tag, image['Id'], image['VirtualSize'], image['Created'])
        sys.exit(0)
    print "INFO: looking up image"
    image = None
    if mode != "gopull":
        image = lookup(name, username, password)
    if image is None and mode != "nopull":
        print "INFO: pulling image"
        if verbose:
            for line in c.pull(name, stream=True):
                d = json.loads(line)
                if 'status' in d and d['status'] == "Downloading" and 'id' in d and 'progress' in d:
                     print "INFO: PULL,%s,%s,%s" % (d['status'],d['id'],d['progress'])
                     sys.stdout.flush()
        else:
            obj = c.pull(name)
        
        image = lookup(name, username, password)
    if image is None:
        print "ERR: Unable to lookup image"
        sys.exit(0)
    if type(image) is not dict or 'Id' not in image:
        print 'ERR: Cannot interpret image id'
        sys.exit(0)
    id = image['Id']

    (imagePath,jsonPath,metadataPath) = package(name, id, format)
    metadata = getmetadata(name, id)
    if metadata is not None:
        if 'env' in metadata:
            for item in metadata['env']:
                print "ENV: %s" % item
        if 'entry' in metadata and metadata['entry'] is not None:
            print "ENTRY: %s" % metadata['entry']
    if imagePath is None:
        print 'ERR: failed to package image'
        sys.exit(0)
    if mode == "nopull":
        print "ID: %s" % id
        sys.exit(0)
    if metadataPath is not None:
        rsync(metadataPath, system)
    if rsync(imagePath,system):
        print "ID: %s" % id
        sys.exit(0)
    print "ERR: Failed to transfer image"
    sys.exit(0)


if __name__ == "__main__":
    main()
