#!/usr/bin/perl
## Shifter, Copyright (c) 2015, The Regents of the University of California,
## through Lawrence Berkeley National Laboratory (subject to receipt of any
## required approvals from the U.S. Dept. of Energy).  All rights reserved.
## 
## Redistribution and use in source and binary forms, with or without
## modification, are permitted provided that the following conditions are met:
##  1. Redistributions of source code must retain the above copyright notice,
##     this list of conditions and the following disclaimer.
##  2. Redistributions in binary form must reproduce the above copyright notice,
##     this list of conditions and the following disclaimer in the documentation
##     and/or other materials provided with the distribution.
##  3. Neither the name of the University of California, Lawrence Berkeley
##     National Laboratory, U.S. Dept. of Energy nor the names of its
##     contributors may be used to endorse or promote products derived from this
##     software without specific prior written permission.
## 
## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
## IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
## ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
## LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
## CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
## SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
## POSSIBILITY OF SUCH DAMAGE.
##  
## You are under no obligation whatsoever to provide any bug fixes, patches, or
## upgrades to the features, functionality or performance of the source code
## ("Enhancements") to anyone; however, if you choose to make your Enhancements
## available either publicly, or directly to Lawrence Berkeley National
## Laboratory, without imposing a separate written license agreement for such
## Enhancements, then you hereby grant the following license: a  non-exclusive,
## royalty-free perpetual license to install, use, modify, prepare derivative
## works, incorporate into other computer software, distribute, and sublicense
## such enhancements or derivative works thereof, in binary and source code
## form.
$|=1;

use IO::Socket::INET;
use Getopt::Long;
use POSIX qw(strftime);

use strict;
use warnings;

my $config_file = "@@@CONFIG_FILE@@@";
my $dockergw_host = `. $config_file; echo \$dockergw_host`;
my $dockergw_port = `. $config_file; echo \$dockergw_port`;
my $batchType = `. $config_file; echo \$batchType`;

my $ret = 0;

my $verbosity_level=1;
my $quiet;
my $verbose;
my $help;
my $username = undef;
my $password = undef;
my $image = undef;
my $registry = undef;
my $system = undef;
my $extra = "";
my $mode = undef;
my $format = "squashfs";
GetOptions('help|h!'       => \$help,
           'verbose|v!'    => \$verbose,
           'quiet|q!'      => \$quiet,
           'image|i=s'    => \$image,
           'username|u=s' => \$username,
           'password|p=s' => \$password,
           'registry|r=s' => \$registry,
           'system|s=s'   => \$system,
           'format|f=s'   => \$format,
);

if ($verbose) {
    $verbosity_level += 1;
}
if ($quiet) {
    $verbosity_level -= 1;
}
if (!defined($image)) {
    if (scalar(@ARGV) > 0) {
        $mode = shift @ARGV;
    }
    if (scalar(@ARGV) > 0) {
        $image = shift @ARGV;
    }
    if (scalar(@ARGV) > 0) {
        usage(1);
    }
}
my @modes = qw(pull images lookup);
if (!grep(/$mode/, @modes)) {
    $image = $mode;
    $mode = "pull";
}
if ((!defined($image) || $image !~ /:/) && $mode ne "images") {
    usage(1);
}
if ($mode eq "images") {
    $image = "fake:ignore";
    $extra .= " mode=images";
}
if ($mode eq "lookup") {
    $extra .= " mode=nopull";
}
if ($mode eq "pull") {
    $extra .= " mode=gopull";
}
if ($format ne "") {
    $extra .= " format=$format";
}
if (!defined($system)) {
    if (-e "/etc/clustername") {
        $system = `cat /etc/clustername`;
        chomp($system);
    }
}
if (!defined($system)) {
    print STDERR "Unknown system.\n";
    usage(1);
}

my $socket = new IO::Socket::INET (
    PeerHost => $dockergw_host,
    PeerPort => $dockergw_port,
    Proto => 'tcp',
) or die("Failed to connect to dockergw");
$socket->send("$image $system$extra\n");
my @imageEnv;
my $entryPoint = undef;
my $result = "";
my $screenStatus = { };
my $currLine = 0;
my $managedLines = 0;
my $displayedPull = 0;
my @images;
while (<$socket>) {
    my $data = $_;
    $data =~ s/^s\+//g;
    $data =~ s/\s+$//g;
    if ($data =~ /^ID:\s+(\S+)$/) {
        $result = $1;
    }
    if ($data =~ /^ERR:\s+(.*)$/) {
        $result = $1;
        $ret = 1;
    }
    if ($data =~ /^ENV:\s+(.*)$/) {
        push(@imageEnv, $1);
    }
    if ($data =~ /^ENTRY:\s+(.*)$/) {
        $entryPoint = $1;
    }
    if ($data =~ /^IMAGE:\s+(.*)$/) {
        my @data = split /,/, $1;
        push(@images, \@data);
    }
    if ($verbosity_level > 0 && $data =~ /^INFO: PULL,(\S+),(\S+),(.*)$/) {
        $displayedPull = 1;
        my $state = $1;
        my $id = $2;
        my $status = $3;
        my $output = "$state: $id $status";
        if (!defined($screenStatus->{$id})) {
            print "\n";
            $managedLines += 1;
            foreach my $tid (keys(%{$screenStatus})) {
                $screenStatus->{$id}->{"line"} += 1;
            }
            $screenStatus->{$id} = {
                "line" => 0,
                "text" => $output,
            }
        }
        $screenStatus->{$id}->{"text"} = $output;
        my $left = length($screenStatus->{$id}->{"text"});
        my $count = $currLine - $screenStatus->{$id}->{"line"};
        my $dir = "B"; #down
        $currLine += $count;
        if ( $count < 0) {
            $count *= -1;
            $dir = "A"; #up
        }
        if ( $count > 0 ) {
            print "\033[$count$dir";
        }
        print "\033[0K " . $screenStatus->{$id}->{"text"};
        $dir="D";
        print "\033[$left$dir";
    }
    if ($verbosity_level > 0 && $data =~ /^META/) {
        print $data . "\n";
    }
}
$socket->close();
if ($displayedPull > 0) { print "\n\n"; }
if ($mode eq "images") {
    @images = sort {$a->[0] cmp $b->[0]} @images;
    foreach my $image (@images) {
        my ($tag,$id,$size,$created) = @{$image};

        my $exp = 0;
        while ($size > 1024 && $exp < 5) {
            $size /= 1024;
            $exp += 1;
        }
        my @suffix = qw(Bytes KB MB GB TB);
        printf "Image: $tag ($id), Size: %0.2f$suffix[$exp], Date: %s\n", $size, strftime("%Y/%m/%d %H:%M:%S", localtime $created);
    }
    exit
}
if ($verbosity_level == 0) {
    foreach my $envItem (@imageEnv) {
        $envItem =~ s/^\s+//g;
        $envItem =~ s/\s+$//g;
        print "ENV:$envItem\n";
    }
    if (defined($entryPoint)) {
        print "ENTRY:$entryPoint\n";
    }
    print "$result\n";
} elsif ($ret == 0 && $result ne "") {
    print "Retrieved docker image $image resolving to ID $result\n\n";
#    print "EXAMPLE Batch Script\n";
#    print "#!/bin/bash -l\n";
#    if ($batchType eq "torque") {
#        print "#PBS -v DOCKER=\"$image\",CRAY_ROOTFS=UDI\n";
#        print "export PBS_NODEFILE=/var/hostsfile\n";
#    }
#    print "module load shifter\n";
#    if ($batchType eq "torque" || $batchType eq "slurmHybrid") {
#        my $app = "<your application>";
#        if (defined($entryPoint)) {
#            $app = $entryPoint;
#        }
#        print "shiftrun $app\n";
#    }
}

exit $ret;


sub usage {
    my $ret = shift;
    print "getDockerImage.pl takes exactly one argument - the docker image\n";
    exit $ret;
}
