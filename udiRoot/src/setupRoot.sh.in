#!/bin/sh

##################
## Setup UDI chroot for docker,chos images
##  Validates user selected chroot image
##  Bind mounts image to $udiMount
##  Bind mounts needed filesystems into the image
##
## Authors:  Douglas Jacobsen, Shane Canon
## 2015/02/27
##
## Note:  This script has been written for the busybox ash, meaning that some
## security features the authors would like to use for a more general purpose
## bash have been omitted.  These include: use of privileged mode (sh -p),
## marking critical functions as readonly (no readonly -f), use of stat instead
## of ls (busybox stat does not offer deterministic formatting), process
## substitution/read instead of set -- $var then examine $1, $2,..., and more.
##################

set -o noglob      ## do not expand filenames

export PATH="/usr/bin:/bin:/usr:sbin:/sbin"
unset LD_LIBRARY_PATH
unset LD_PRELOAD
unset IFS

context=""
if [[ -z "$NOCONTEXT" ]]; then
    context="/dsl"
fi
CONFIG_FILE="${context}@@@CONFIG_FILE@@@"
INCLUDE_FILE="${context}@@@INCLUDE_FILE@@@"
readonly CONFIG_FILE
readonly INCLUDE_FILE

## stub functions to be replaced by site-specific include file
preSiteFsBindMount() {
    return 0
}
postSiteFsBindMount() {
    return 0
}

@@@INCLUDE shifterLibCore.sh@@@

## parse command line arguments
## global variables:
##  udiRootType
##  udiRootValue
##  udiUser
##  volumes
parseArguments() {
    udiRootType="$1"
    udiRootValue="$2"
    udiUser="invalidUser"
    udiUid="UNSET"
    minNodes=""
    readonly udiRootType
    readonly udiRootValue
    shift 2
    volumes=""
    while getopts ":v:s:u:U:N:" opt; do
        case "${opt}" in
            v)
                volumes="${volumes}|${OPTARG}"
                ;;
            s)
                sshPubKey="${OPTARG}"
                ;;
            u)
                udiUser="${OPTARG}"
                ;;
            U)
                udiUid="${OPTARG}"
                ;;
            N)
                minNodes="${OPTARG}"
                ;;
            \?)
                echo "Invalid option: -${OPTARG}" >&2
                exit 1
                ;;
            :)
                echo "Option -${OPTARG} requires an argument" >&2
                exit 1
                ;;
        esac
    done
    if [[ -n "${volumes}" ]]; then
        volumes="${volumes:1}" ## remove leading |
    fi
    readonly volumes
    readonly sshPubKey
    readonly udiUser
    readonly udiUid
}

stripLeadingSlash() {
    local string
    string="$1"
    while [[ "${string:0:1}" = "/" ]]; do
        string="${string:1}"
    done
    echo "${string}"
}

containsItem () {
    local tgt
    tgt="$1"
    shift
    [[ $# -eq 0 ]] && return 1
    while true; do
        [[ "$1" = "$tgt" ]] && return 0
        [[ $# -eq 0 ]] && break
        shift
    done
    return 1
}

bindImageIntoMnt() {
    local localDir
    local remoteDir
    remoteDir="$1"
    localDir="$2"

    # mount the image into the new mount
    cd "$localDir"
    IFS=$'\n'
    for item in $(ls "$remoteDir"); do
        unset IFS
        ## weed out possibly dangerous items
        dir="${item//[^a-zA-Z0-9_+\-\.]/}"
        if [[ ! -e "${remoteDir}/${item}" && ! -L "${remoteDir}/${item}" ]]; then
            continue
        fi
        # don't do anything to "reserved" paths
        if [[ -e "$item" || -L "$item" ]]; then
            continue
        fi
        # properly copy symlinks
        if [[ -L "$remoteDir/$item" ]]; then
            cp -P "$remoteDir/$item" "$item"
            continue
        fi
        # copy files
        if [[ -f "$remoteDir/$item" ]]; then
            cp -p "$remoteDir/$item" "$item"
            continue
        fi
        # bind mount directories
        if [[ -d "$remoteDir/$item" ]]; then
            mkdir "$localDir/$item"
            mount --bind "$remoteDir/$item" "${localDir}/$item"
            mount -o bind,remount,nodev,nosuid "${localDir}/$item"
        fi
    done
}

setupImageSsh() {
    local mntPoint
    mntPoint="$1"
    if [[ -d "$sshPath" ]]; then
        cd "${mntPoint}"
        cp -rp "$sshPath"/udiImage ./opt/
        cd "${mntPoint}/opt/udiImage"
        chmod -R a+rX .
        ./bin/ssh-keygen -t dsa -f ./etc/ssh_host_dsa_key -N '' > /dev/null 2>&1
        ./bin/ssh-keygen -t rsa -f ./etc/ssh_host_rsa_key -N '' > /dev/null 2>&1
        ./bin/ssh-keygen -t ed25519 -f ./etc/ssh_host_ed25519_key -N '' > /dev/null 2>&1
        ./bin/ssh-keygen -t ecdsa -f ./etc/ssh_host_ecdsa_key -N '' > /dev/null 2>&1
        cat ./etc/sshd_config | sed "s|AllowUsers ToBeReplaced|AllowUsers $udiUser|g" > ./etc/sshd_config.new
        mv ./etc/sshd_config.new ./etc/sshd_config
        if [[ -n "$sshPubKey" && -n "$udiUser" ]]; then
            echo "$sshPubKey" > ./etc/user_auth_keys
            chown "$udiUid" ./etc/user_auth_keys
            chmod 600 ./etc/user_auth_keys
        fi
        chmod 600 ./etc/sshd_config

        ## replace ssh in any "normal" location in the image
        if [[ -f "${mntPoint}/usr/bin/ssh" && -f "${mntPoint}/opt/udiImage/bin/ssh" ]]; then
            mount --bind "${mntPoint}/opt/udiImage/bin/ssh" "${mntPoint}/usr/bin/ssh"
        fi
        if [[ -f "${mntPoint}/bin/ssh" && -f "${mntPoint}/opt/udiImage/bin/ssh" ]]; then
            mount --bind "${mntPoint}/opt/udiImage/bin/ssh" "${mntPoint}/bin/ssh"
        fi
        if [[ -f "${mntPoint}/etc/ssh/ssh_config" ]]; then
            cp -p "${mntPoint}/opt/udiImage/etc/ssh_config" "${mntPoint}/etc/ssh/ssh_config"
        fi
    fi
}

setupHostlistFile() {
    local mntPoint
    mntPoint="$1"
    if [[ -n "$minNodes" ]]; then
        for node in $minNodes; do
            IFS="/"
            set -- $node
            unset IFS
            name="$1"
            count="$2"
            idx=0
            while [[ $idx -lt $count ]]; do
                echo "$name" >> "$mntPoint/var/hostsfile"
                idx=$(( $idx + 1 ))
            done
        done
    fi
}

startSshd() {
    local mntPoint
    mntPoint="$1"
    chroot "$mntPoint" /opt/udiImage/sbin/sshd
}

setupVFSMount () {
    set -e
    local mntPoint
    local fs
    local dir
    local item
    local imageDir
    local volMap
    local src
    local dest
    local option
    mntPoint="$1"
    imageDir="$2"

    ## create tmpfs/rootfs for our /
    ## this is to ensure there are writeable areas for manipulating the image
    mount -o nosuid,nodev -t rootfs none "${mntPoint}"
    cd "${mntPoint}"

    ### premount -- should be defined in include file
    preSiteFsBindMount
    cd "${mntPoint}"

    ### perform the bind mounts
    if [[ -n "$siteFs" ]]; then
        for fs in $siteFs; do
            mkdir "$fs"
            mount -o bind "/$fs" "$fs"
            mount -o bind,remount,nosuid,nodev "${mntPoint}/$fs"
        done
    fi

    ### postmount -- should be defined in include file
    postSiteFsBindMount
    cd "${mntPoint}"

    ## make some aspects of the local environment available
    mkdir -p etc
    mkdir -p local/etc
    mount -o bind $context/etc local/etc
    mount -o bind,remount,ro,nodev,nosuid "${mntPoint}/local/etc"

    ## /etc/hosts needs to match the local machine for safe and correct communication
    cd etc
    ln -s /local/etc/hosts hosts

    ## cray shared-root etc needs /.shared
    cd "${mntPoint}"
    mkdir -p .shared
    mount -o bind $context/.shared .shared
    mount -o bind,remount,ro,nodev,nosuid .shared

    ## reserve some directories in "/" that will be handled explicitly
    mkdir -p etc/udiImage
    mkdir -p opt/udiImage
    mkdir -p var/empty
    mkdir -p var/run
    mkdir -p etc/site
    mkdir -p proc
    mkdir -p sys
    mkdir -p dev
    mkdir -p tmp
    mount -o bind /tmp tmp
    mount -o bind,remount,nosuid,nodev tmp
    
    # mount the image into the new mount
    bindImageIntoMnt "$imageDir" "$mntPoint"

    # take care of opt separately
    if [[ -e "$imageDir/opt" ]]; then
        bindImageIntoMnt "$imageDir/opt" "$mntPoint/opt"
    fi

    if [[ -e "$imageDir/var" ]]; then
        bindImageIntoMnt "$imageDir/var" "$mntPoint/var"
    fi

    # setup image ssh
    cd "${mntPoint}"
    setupImageSsh "$mntPoint"

    # setup hostslist
    setupHostlistFile "$mntPoint"

    ## merge image etc, site customizations, and local customizations into /etc
    cd "${mntPoint}"
    if [[ -e "$imageDir/etc" ]]; then
        mount -o bind "$imageDir/etc" etc/udiImage
        mount -o bind,remount,nodev,nosuid "${mntPoint}/etc/udiImage"
        cd etc
        IFS=$'\n'
        for item in $(ls udiImage); do
            unset IFS
            ## weed out possibly dangerous items
            item="${item//[^a-zA-Z0-9_+\-\.]/}"
            [[ ! -e "udiImage/${item}"  && ! -L "udiImage/${item}" ]] && continue
            [[ -e "$item" || -L "$item" ]] && continue
            ln -s "udiImage/$item" .
        done
    fi
    if [[ -e "$etcDir" ]]; then
        IFS=$'\n'
        for item in $(ls "$etcDir"); do
            unset IFS
            ## weed out possibly dangerous items
            item="${item//[^a-zA-Z0-9_+\-\.]/}"
            if [[ ! -e "$etcDir/${item}" && ! -L "$etcDir/${item}" ]]; then
                continue
            fi
            cp -p "$etcDir/$item" "${mntPoint}/etc/site"
            if [[ -e "$item" || -L "$item" ]]; then
                rm "$item"
            fi
            ln -s "site/$item" "$item"
        done
        ## take care of passwd
        [[ -e passwd ]] && rm passwd
        ln -s site/udi_passwd passwd
        [[ -e group ]] && rm group
        ln -s site/udi_group group
        [[ -e nsswitch.conf ]] && rm nsswitch.conf
        ln -s site/nsswitch.conf nsswitch.conf
    fi

    ## mount up linux needs
    mount -t proc none "${mntPoint}/proc"
    mount -o bind /dev "${mntPoint}/dev"
    mount -o bind,remount,nosuid "${mntPoint}/dev"
    mount -t devpts none "${mntPoint}/dev/pts"
    mount -o bind /sys "${mntPoint}/sys"
    mount -o bind,remount,nosuid "${mntPoint}/sys"

    ## perform any user-requested bind-mounts
    ##    any leading slashes are stripped to force the bind mount to *only*
    ##    occur within the chroot area
    cd "${mntPoint}"
    IFS="|"
    for volMap in ${volumes}; do
        IFS=":"
        set -- ${volMap} ## cannot quote
        unset IFS
        src=$(stripLeadingSlash "$1")
        dest=$(stripLeadingSlash "$2")
        option="NONE"
        shift 2
        if [[ -n "$1" ]]; then
            option="$1"
            shift
        fi
        if [[ -e "$src" && -e "$dest" ]]; then
            mount -o bind "$src" "$dest"
            if [[ "$option" == "ro" ]]; then
                mount -o bind,remount,ro,nodev,nosuid "$dest"
            else
                mount -o bind,remount,nodev,nosuid "$dest"
            fi
        fi
    done
    unset IFS
    mount -o remount,ro,nosuid,nodev "${mntPoint}"
    set +e
}

## loadKernelModule - ensure specified kernel module is loaded
##   checks to see if kernel module is loaded.  if it isn't the module is loaded
##   and logged to the kmodCache for later removal
##
##   returns 0 if module is loaded
##   returns 1 if module failed to load
loadKernelModule() {
    local kmodName
    local kmodPath
    local loadModule
    kmodName="$1"
    kmodPath="$2"
    loadModule=0
    /sbin/lsmod | egrep "^$kmodName$" || loadModule=1
    if [[ $loadModule -eq 1 && -e "$kmodPath" ]]; then
        /sbin/insmod "$kmodPath" || return 1
        echo "$kmodName" >> "$kmodCache"
    fi
    return 0
}

setupLoopbackMount() {
    local imageFile
    local kmodPath
    local fstype
    local mntPoint
    mntPoint="$1"
    imageFile="$2"
    kmodPath="$3"
    fstype="$4"

    [[ -n "${mntPoint}" ]] || die "Unknown location for mntPoint"

    loadKernelModule "loop"    "${kmodPath}"/drivers/block/loop.ko
    loadKernelModule "mbcache" "${kmodPath}"/fs/mbcache.ko
    loadKernelModule "jbd2"    "${kmodPath}"/fs/jbd2/jbd2.ko
    loadKernelModule "ext4"    "${kmodPath}"/fs/ext4/ext4.ko
    loadKernelModule "cramfs"  "${kmodPath}"/fs/cramfs/cramfs.ko

    mkdir -p "${mntPoint}" || die "Failed to create mount point ${mntPoint}"
    mount -t "${fstype}" -o loop,ro,nodev,nosuid "${imageFile}" "${mntPoint}" || die "Failed to mount image file ${imageFile}"
}


# global variables
# udiRootType ## argument
# udiRootValue ## argument
# volumes ## arguments
# mapPath ## config
# dockerPath ## config
# chosPath   ## config

main() {
    local targetType
    local target
    local line
    local linePrefix
    local image
    local imageType
    local basePath
    local fullPath

    parseArguments "$@" || die "Unable to parse arguments"
    parseConfiguration || die "Unable to parse configuration"
    if [[ "$udiRootType" = "CHOS" || "$udiRootType" = "chos" ]]; then
        targetType="chos"
    fi
    if [[ "$udiRootType" = "DOCKER" || "$udiRootType" = "docker" ]]; then
        targetType="docker"
    fi
    if [[ -n "$udiRootType" ]]; then
        target="$udiRootValue"
    fi

    containsItem "$targetType" "chos" "docker" || die "Invalid image target type: $targetType"

    ## since $target is user provided, need to sanitize
    target=${target//[^a-zA-Z0-9_:\.]/}

    linePrefix="$targetType;$target;"
    if [[ "$targetType" = "docker" ]]; then
        imageType="ext4Image"
        image="${target}.ext4"
    else
        line=$( egrep "^$linePrefix" "$mapPath" ) || die "Cannot find $targetType image \"$target\". Failed."
        image=$( echo "$line" | awk -F ';' '{print $3}' ) || die "Cannot identify path for $targetType image \"$target\". Failed."
        imageType=$( echo "$line" | awk -F ';' '{print $4}' ) || die "Cannot identify imageType for $targetType image \"$target\". Failed."
    fi

    containsItem "$imageType" "vfs" "ext4Image" "cramfsImage" || die "Invalid imageType for $targetType image \"$target\". Failed."

    ## get base path for this target type
    basePath="NONE"
    case "${targetType}" in
        docker) basePath="${dockerPath}" ;;
        chos)   basePath="${chosPath}"   ;;
        *)      die "Invalid target!"
    esac
  
    [[ -n "$basePath" ]] || die "Invalid base path for $targetType"
    [[ "$basePath" != "/" ]] || die "Base path cannot be /"

    ## get final path to image
    fullPath="${basePath}/${image}"
    [[ -e "$fullPath" ]] || die "Path to $targetType image \"$target\" does not exist: $fullPath"

    ## start doing bind mounts
    mkdir -p "$udiMount"
    if [[ "$imageType" = "vfs" ]]; then
        setupVFSMount "$udiMount" "$fullPath"
    elif [[ "$imageType" = "ext4Image" ]]; then
        setupLoopbackMount "$loopMount" "$fullPath" "$kmodDir" "ext4" || die "Failed to setup image mount"
        setupVFSMount "$udiMount" "$loopMount"
    elif [[ "$imageType" = "cramfsImage" ]]; then
        setupLoopbackMount "$loopMount" "$fullPath" "$kmodDir" "cramfs" || die "Failed to setup image mount"
        setupVFSMount "$udiMount" "$loopMount"
    else
        exit 1
    fi
    if [[ -e /proc/sys/net/krsip/request ]]; then 
        echo "ccm on" > /proc/sys/net/krsip/request
    fi
    if [[ -n "$sshPubKey" ]]; then
        startSshd "$udiMount"
    fi
}

if [[ -z "${DEBUG_UDIROOT}" ]]; then
    main "$@"
fi
