#!/bin/sh

##################
## Setup UDI chroot for docker,chos images
##  Validates user selected chroot image
##  Bind mounts image to $udiMount
##  Bind mounts needed filesystems into the image
##
## Authors:  Douglas Jacobsen, Shane Canon
## 2015/02/27
##################

set -o noglob      ## do not expand filenames

export PATH="/usr/bin:/bin"
export LD_LIBRARY_PATH=""
export LD_PRELOAD=""
unset IFS

CONFIG_FILE=@@@CONFIG_FILE@@@
INCLUDE_FILE=@@@INCLUDE_FILE@@@
readonly CONFIG_FILE
readonly INCLUDE_FILE

## stub functions to be replaced by site-specific include file
preSiteFsBindMount() {
    return 0
}
postSiteFsBindMount() {
    return 0
}

die() {
    echo "$1"
    exit 1
}

validateFile() {
    local fname
    local lsdata
    local perm
    local uid
    local gid
    fname="$1"
    expected_perm="$2"
    shift
    if [[ -z "${fname}" || -z "${expected_perm}" ]]; then
        return 1
    fi
    if [[ ! -e "${fname}" ]]; then
        echo "${fname} does not exist!" 1>&2
        return 1
    fi
    lsdata=$(ls -lnd "${fname}")
    if [[ $? -ne 0 ]]; then
        echo "Failed to list ${fname}"
    fi
    set -- ${lsdata} ## cannot quote
    perm="$1"
    uid="$3"
    gid="$4"
    if [[ "$perm" != "$expected_perm" ]]; then
        echo "Incorrect permissions on $fname, expected $expected_perm" 1>&2
        return 1
    fi
    if [[ "$uid" != "0" || "$gid" != "0" ]]; then
        echo "Incorrect ownership of $fname" 1>&2
        return 1
    fi
    return 0
}

parseConfiguration() {
    ## read configuration
    validateFile "${CONFIG_FILE}" "-r--r--r--" || die "Invalid configuration file"
    source "${CONFIG_FILE}"
    readonly udiMount
    readonly loopMount
    readonly chosPath
    readonly dockerPath
    readonly udiRootPath
    readonly mapPath
    readonly etcDir
    readonly kmodDir
    readonly kmodCache
    readonly siteFs
    readonly system

    if [[ -z "${udiMount}" ]]; then die "Unknown root path"; fi
    if [[ -z "${loopMount}" ]]; then die "Unknown loop mount path"; fi
    if [[ ! -d "${dockerPath}" ]]; then die "Inaccessible docker path"; fi
    if [[ ! -d "${chosPath}" ]]; then die "Inaccessible chos path"; fi
    if [[ ! -d "${udiRootPath}" ]]; then die "Inaccessible installation dir"; fi
    validateFile "${udiRootPath}" "drwxr-xr-x" || die "Incorrect permissions on installation dir"
    validateFile "${mapPath}" "-r--------" || die "Invalid map file"
    if [[ ! -d "${etcDir}" ]]; then die "Inaccessible site etc dir"; fi
    validateFile "${etcDir}" "drwxr-xr-x" || die "Incorrect permissions on site etc dir"
    if [[ ! -d "${kmodDir}" ]]; then die "Inaccessible kernel module dir"; fi
    validateFile "${kmodDir}" "drwxr-xr-x" || die "Incorrect permissions on kernel module dir"
    if [[ -z "${kmodCache}" ]]; then die "Unknown kernel module cache file location"; fi
    if [[ -z "${system}" ]]; then die "Unknown system"; fi

    validateFile "${INCLUDE_FILE}" "-r--------" || die "Invalid include file"
    source "${INCLUDE_FILE}"
}

## parse command line arguments
## global variables:
##  udiRootType
##  udiRootValue
##  volumes
parseArguments() {
    udiRootType="$1"
    udiRootValue="$2"
    readonly udiRootType
    readonly udiRootValue
    shift 2
    volumes=""
    while getopts ":v:" opt; do
        case "${opt}" in
            v)
                volumes="${volumes}|${OPTARG}"
                ;;
            \?)
                echo "Invalid option: -${OPTARG}" >&2
                exit 1
                ;;
            :)
                echo "Option -${OPTARG} requires an argument" >&2
                exit 1
                ;;
        esac
    done
    if [[ -n "${volumes}" ]]; then
        volumes="${volumes:1}" ## remove leading |
    fi
    readonly volumes
}

stripLeadingSlash() {
    local string
    string="$1"
    while [[ "${string:0:1}" = "/" ]]; do
        string="${string:1}"
    done
    echo "${string}"
}

containsItem () {
    local tgt
    tgt="$1"
    shift
    [[ $# -eq 0 ]] && return 1
    while true; do
        [[ "$1" = "$tgt" ]] && return 0
        [[ $# -eq 0 ]] && break
        shift
    done
    return 1
}

setupVFSMount () {
    set -e
    local mntPoint
    local fs
    local dir
    local item
    local imageDir
    local volMap
    local src
    local dest
    local option
    mntPoint="$1"
    imageDir="$2"

    ## create tmpfs/rootfs for our /
    ## this is to ensure there are writeable areas for manipulating the image
    mount -o nosuid,nodev -t rootfs none "${mntPoint}"
    cd "${mntPoint}"

    ### premount -- should be defined in include file
    preSiteFsBindMount
    cd "${mntPoint}"

    ### perform the bind mounts
    if [[ -n "$siteFs" ]]; then
        for fs in $siteFs; do
            mkdir "$fs"
            mount -o bind "/$fs" "$fs"
            mount -o bind,remount,nosuid,nodev "${mntPoint}/$fs"
        done
    fi

    ### postmount -- should be defined in include file
    postSiteFsBindMount
    cd "${mntPoint}"

    ## make some aspects of the local environment available
    mkdir -p local/etc
    mount -o bind /dsl/etc local/etc
    mount -o bind,remount,nodev,nosuid "${mntPoint}/local/etc"
    mkdir -p .shared
    mount -o bind /dsl/.shared .shared
    mount -o bind,remount,nodev,nosuid .shared

    ## reserve some directories in "/" that will be handled explicitly
    mkdir -p etc/udiImage
    mkdir -p etc/site
    mkdir -p proc
    mkdir -p sys
    mkdir -p dev
    mkdir -p tmp
    mount -o bind /tmp tmp
    mount -o bind,remount,nosuid,nodev tmp
    
    # mount the image into the new mount
    IFS=$'\n'
    for dir in $(ls "$imageDir"); do
        unset IFS
        ## weed out possibly dangerous items
        dir="${dir//[^a-zA-Z0-9_+\-\.]/}"
        if [[ ! -e "${imageDir}/${dir}" ]]; then
            continue
        fi
        # don't do anything to "reserved" paths
        if [[ -e "$dir" ]]; then
            continue
        fi
        # properly copy symlinks
        if [[ -L "$imageDir/$dir" ]]; then
            cp -P "$imageDir/$dir" "$dir"
            continue
        fi
        # copy files
        if [[ -f "$imageDir/$dir" ]]; then
            cp -p "$imageDir/$dir" "$dir"
            continue
        fi
        # bind mount directories
        if [[ -d "$imageDir/$dir" ]]; then
            mkdir "$dir"
            mount --bind "$imageDir/$dir" "${mntPoint}/$dir"
            mount -o bind,remount,nodev,nosuid "${mntPoint}/$dir"
        fi
    done

    ## merge image etc, site customizations, and local customizations into /etc
    if [[ -e "$imageDir/etc" ]]; then
        mount -o bind "$imageDir/etc" etc/udiImage
        mount -o bind,remount,nodev,nosuid "${mntPoint}/etc/udiImage"
        cd etc
        IFS=$'\n'
        for item in $(ls udiImage); do
            unset IFS
            ## weed out possibly dangerous items
            item="${item//[^a-zA-Z0-9_+\-\.]/}"
            if [[ ! -e "udiImage/${item}" ]]; then
                continue
            fi
            ln -s "udiImage/$item" .
        done
        IFS=$'\n'
        for item in $(ls "$etcDir"); do
            unset IFS
            ## weed out possibly dangerous items
            item="${item//[^a-zA-Z0-9_+\-\.]/}"
            if [[ ! -e "$etcDir/${item}" ]]; then
                continue
            fi
            cp -p "$etcDir/$item" "${mntPoint}/etc/site"
            if [[ -e "$item" ]]; then
                rm "$item"
            fi
            ln -s "site/$item" "$item"
        done
        ## take care of passwd
        if [[ -e passwd ]]; then
            rm passwd
        fi
        ln -s site/udi_passwd passwd
        if [[ -e group ]]; then
            rm group
        fi
        ln -s site/udi_group group
    fi

    ## mount up linux needs
    mount -t proc none "${mntPoint}/proc"
    mount -o bind /dev "${mntPoint}/dev"
    mount -o bind,remount,nosuid "${mntPoint}/dev"
    mount -o bind /sys "${mntPoint}/sys"
    mount -o bind,remount,nosuid "${mntPoint}/sys"

    ## perform any user-requested bind-mounts
    ##    any leading slashes are stripped to force the bind mount to *only*
    ##    occur within the chroot area
    cd "${mntPoint}"
    IFS="|"
    for volMap in ${volumes}; do
        IFS=":"
        set -- ${volMap} ## cannot quote
        unset IFS
        src=$(stripLeadingSlash "$1")
        dest=$(stripLeadingSlash "$2")
        option="NONE"
        shift 2
        if [[ -n "$1" ]]; then
            option="$1"
            shift
        fi
        if [[ -e "$src" && -e "$dest" ]]; then
            mount -o bind "$src" "$dest"
            if [[ "$option" == "ro" ]]; then
                mount -o bind,remount,ro,nodev,nosuid "$dest"
            else
                mount -o bind,remount,nodev,nosuid "$dest"
            fi
        fi
    done
    unset IFS
    set +e
}

## loadKernelModule - ensure specified kernel module is loaded
##   checks to see if kernel module is loaded.  if it isn't the module is loaded
##   and logged to the kmodCache for later removal
##
##   returns 0 if module is loaded
##   returns 1 if module failed to load
loadKernelModule() {
    local kmodName
    local kmodPath
    local loadModule
    kmodName="$1"
    kmodPath="$2"
    loadModule=0
    /sbin/lsmod | egrep "^$kmodName$" || loadModule=1
    if [[ $loadModule -eq 1 && -e "$kmodPath" ]]; then
        /sbin/insmod "$kmodPath" || return 1
        echo "$kmodName" >> "$kmodCache"
    fi
    return 0
}

setupLoopbackMount() {
    local imageFile
    local kmodPath
    local fstype
    local mntPoint
    mntPoint="$1"
    imageFile="$2"
    kmodPath="$3"
    fstype="$4"

    [[ -n "${mntPoint}" ]] || die "Unknown location for mntPoint"

    loadKernelModule "loop"    "${kmodPath}"/drivers/block/loop.ko
    loadKernelModule "mbcache" "${kmodPath}"/fs/mbcache.ko
    loadKernelModule "jbd2"    "${kmodPath}"/fs/jbd2/jbd2.ko
    loadKernelModule "ext4"    "${kmodPath}"/fs/ext4/ext4.ko
    loadKernelModule "cramfs"  "${kmodPath}"/fs/cramfs/cramfs.ko

    mkdir -p "${mntPoint}" || die "Failed to create mount point ${mntPoint}"
    mount -t "${fstype}" -o loop,ro,nodev,nosuid "${imageFile}" "${mntPoint}" || die "Failed to mount image file ${imageFile}"
}

# global variables
# udiRootType ## argument
# udiRootValue ## argument
# volumes ## arguments
# mapPath ## config
# dockerPath ## config
# chosPath   ## config

main() {
    local targetType
    local target
    local line
    local linePrefix
    local image
    local imageType
    local basePath
    local fullPath

    parseArguments "$@" || die "Unable to parse arguments"
    parseConfiguration || die "Unable to parse configuration"
    if [[ "$udiRootType" = "CHOS" ]]; then
        targetType="chos"
    fi
    if [[ "$udiRootType" = "DOCKER" ]]; then
        targetType="docker"
    fi
    if [[ -n "$udiRootType" ]]; then
        target="$udiRootValue"
    fi

    containsItem "$targetType" "chos" "docker" || die "Invalid image target type: $targetType"

    ## since $target is user provided, need to sanitize
    target=${target//[^a-zA-Z0-9_:\.]/}

    linePrefix="$targetType;$target;"
    if [[ "$targetType" = "docker" ]]; then
        imageType="ext4Image"
        image="${target}.ext4"
    else
        line=$( egrep "^$linePrefix" "$mapPath" ) || die "Cannot find $targetType image \"$target\". Failed."
        image=$( echo "$line" | awk -F ';' '{print $3}' ) || die "Cannot identify path for $targetType image \"$target\". Failed."
        imageType=$( echo "$line" | awk -F ';' '{print $4}' ) || die "Cannot identify imageType for $targetType image \"$target\". Failed."
    fi

    containsItem "$imageType" "vfs" "ext4Image" "cramfsImage" || die "Invalid imageType for $targetType image \"$target\". Failed."

    ## get base path for this target type
    basePath="NONE"
    case "${targetType}" in
        docker) basePath="${dockerPath}" ;;
        chos)   basePath="${chosPath}"   ;;
        *)      die "Invalid target!"
    esac
  
    [[ -n "$basePath" ]] || die "Invalid base path for $targetType"
    [[ "$basePath" != "/" ]] || die "Base path cannot be /"

    ## get final path to image
    fullPath="${basePath}/${image}"
    [[ -e "$fullPath" ]] || die "Path to $targetType image \"$target\" does not exist: $fullPath"

    ## start doing bind mounts
    mkdir -p "$udiMount"
    if [[ "$imageType" = "vfs" ]]; then
        setupVFSMount "$udiMount" "$fullPath"
    elif [[ "$imageType" = "ext4Image" ]]; then
        setupLoopbackMount "$loopMount" "$fullPath" "$kmodDir" "ext4" || die "Failed to setup image mount"
        setupVFSMount "$udiMount" "$loopMount"
    elif [[ "$imageType" = "cramfsImage" ]]; then
        setupLoopbackMount "$loopMount" "$fullPath" "$kmodDir" "cramfs" || die "Failed to setup image mount"
        setupVFSMount "$udiMount" "$loopMount"
    else
        exit 1
    fi
}

if [[ -z "${DEBUG_UDIROOT}" ]]; then
    main "$@"
fi
