#!/bin/sh 
# Copyright 2011 Cray Inc.  All Rights Reserved.
# Unpublished Proprietary Information.  This unpublished work is protected 
# to trade secret, copyright and other laws.  Except as permitted by 
# contract or express written permission of Cray Inc., no part of this work 
# or its content may be used, reproduced or disclosed in any form.
# prologue gets 3 arguments:
# 1 -- jobid
# 2 -- user
# 3 -- grp
#
CCM_JOBID=$1
CCM_JID=`echo $CCM_JOBID | awk -F. '{print $1}'`
CCM_USER=$2
CCM_GROUP=$3
UDI_ROOT_TYPE=$4
UDI_ROOT_VALUE=$5

CCM_APID_TIMEOUT=15

CRAY_QSTAT_PATH="/opt/pbs/default/bin"
CRAY_BATCH_VAR="/var/spool/PBS"
CCM_QUEUES="ccm_queue"

LLMLOGGER="/opt/cray/llm/default/bin/xtlog"
LLMCONF="/etc/opt/cray/llm/llm.conf"

udiRootSetupPath=@@@PREFIX@@@
exit_code=0

# Set apstat -n output columns
export apstat_nodeTable="NID,Arch,State,HW,Rv,Pl,PgSz,Avl,Conf,Placed,PEs,Apids"

PATH=${PATH}:/opt/cray/alps/default/bin/

DOCKER=$( /usr/syscom/nsg/sbin/qgetenv $1 DOCKER 2>/dev/null )
CHOS=$( /usr/syscom/nsg/sbin/qgetenv $1 CHOS 2>/dev/null )
if [ "x${DOCKER}${CHOS}" == "x" ]; then
    exit
fi


echo "Deconstructing UdiRoot environment, Please Wait"

        if [ -z "$CCM_BATCH_RUNDIR" ] ; then
            ccm_rundir=/var/run/crayccm_udiroot
        else
            ccm_rundir=$CCM_BATCH_RUNDIR 
        fi

        mkdir -p $ccm_rundir
        chmod 755 $ccm_rundir

        # create running pid dir for ccmlaunch
        if [ ! -d $ccm_rundir/$CCM_USER ] ; then
            mkdir -p $ccm_rundir/$CCM_USER
            chmod 1755 $ccm_rundir 
            chmod 700 $ccm_rundir/$CCM_USER
            chown $CCM_USER $ccm_rundir/$CCM_USER
        fi

        touch $ccm_rundir/$CCM_USER/$CCM_JOBID.run
        chmod a+r $ccm_rundir/$CCM_USER/$CCM_JOBID.run

        user_data=`/opt/cray/ccm/default/bin/xtgetpwi -d -u $CCM_USER | tr -s "\n" " "`
        CCM_HOMEDIR=$(echo $user_data | awk '{print $1}')
        CCM_UID=$(echo $user_data | awk '{print $2}')

        if [ -f /opt/xt-boot/default/bin/snos64/xtprocadmin ] ; then 
            xtprocadmin_cmd=/opt/xt-boot/default/bin/snos64/xtprocadmin
        else
            xtprocadmin_cmd=/opt/cray/sdb/default/bin/xtprocadmin
        fi

        $xtprocadmin_cmd -E > /dev/null

        job_nodelist=$ccm_rundir/ccm_nodelist.$CCM_JOBID
        placed_nodelist=$ccm_rundir/placed_nodelist.$CCM_JOBID

        # remove any old temporary file of type nodelist
        rm -f $job_nodelist
        rm -f $placed_nodelist

        job_count=0

        while [ $job_count -lt $CCM_APID_TIMEOUT ] ; do
            # under certain edge cases, CCM_JOBID might not be bound.  Specifically this seems
            # to occur a lot when multiple qsubs are initiated quickly.  Always reobtain the reservation
            # id on every iteration to maximize chance of success 
            rid=`echo $CCM_JOBID | awk -F. '{print $1}'`
            # CCM_JOBID is the batchid passed in from the batch system, typically in the format
            # 123.sdb.  We only want the numeric portion.

            jid=`apstat -r | grep "batch:$rid " | grep -v ^A | awk '{print $1}'`
            # We are trying to get the ResId.
            # apstat -r output looks like:
            #  ResId     ApId From           Arch   PEs N d Memory State
            #    524  5385733 batch:2274371    XT   500 32 1   1024 conf,claim
            # A  524  5385734 batch:2274371    XT   384 - -   1024 conf,claim
            if [ "$jid" != "" ]; then
    	        break
            fi
            echo waiting for jid....
            sleep 1
            job_count=$(($job_count+1))
        done

        if [ $job_count -eq $CCM_APID_TIMEOUT ] ; then 
            echo "CCM could not get job reservation"
            exit 1 
        fi 

        #
        # Create nodelist
        #
        declare -a nodelist
        nodelist=(`apstat -n -R $jid | grep "XT" | grep "UP" | awk '{printf "nid%05d\n", $1}'`)
        # The nodelist is list of hostname entries in the format nidxxxxx, one per line.
        # We build this out of the first column of the apstat -n -R <jobid> output:
        #  NID Arch State HW Rv Pl PgSz     Avl    Conf  Placed  PEs Apids
        #  140   XT UP  B 32 32 32   4K 8388608 8388608 8388608   32 6968951

        declare -a placedlist
        placedlist=(`apstat -n -R $jid | grep "XT" | grep "UP" | awk '{print $1}'`)
        # The placed is list of nids, one per line.
        # We build this out of the first column of the apstat -n -R <jobid> output:
        #  NID Arch State HW Rv Pl PgSz     Avl    Conf  Placed  PEs Apids
        #  140   XT UP  B 32 32 32   4K 8388608 8388608 8388608   32 6968951
        
        placed_length=${#placedlist[@]}
        i=0
        while [ $i -lt $placed_length ] ; do
            echo ${placedlist[$i]} >> $placed_nodelist
            let i=$i+1
        done 

        chmod a+r $placed_nodelist

        # determine nodelist by processing the following output format
        #     PE 0, cmd 0, nid 20, CPU 0x1, map 0x1, accels 0
        #     PE 1, cmd 0, nid 20, CPU 0x2, map 0x1, accels 0
        #     PE 2, cmd 0, nid 21, CPU 0x1, map 0x1, accels 0
        #     PE 3, cmd 0, nid 21, CPU 0x2, map 0x1, accels 0

        apstat -rvvv -R $jid | awk '/^[ ]*PE / { printf "nid%05d\n", $6 }' | sort >$job_nodelist

        # make job nodelist readable by all
        chmod a+r $job_nodelist

        ccm_nodelist=`cat $job_nodelist | sort -u | /usr/bin/tr -s '\n' ' '`

        ccm_init_log=$ccm_rundir/ccm_initlog.$CCM_JOBID
 

        #su $CCM_USER -c "/opt/cray/ccm/default/sbin/ccm_userenv $CCM_USER $CCM_HOMEDIR $CCM_JOBID /var/run/crayccm 1"
        ## CANT CALL because ccm_userenv has default ccm_runder baked-in


        #
        # Parallel launch using xtxqtcmd
        #

        if [ -f /opt/cray/nodehealth/default/bin/xtxqtcmd ]; then
          xtxqtcmd_path=/opt/cray/nodehealth/default/bin/xtxqtcmd
        else
           echo "CCM could not find xtxqtcmd. Exiting"
           exit 1
        fi

        ccm_init_nodelist=$ccm_rundir/ccm_init_nodelist.epilogue.$CCM_JOBID

        if [ ! -f $ccm_init_nodelist ] ; then 
            cat $job_nodelist | sort -u > $ccm_init_nodelist
            chown root:root $ccm_init_nodelist
            chmod 600 $ccm_init_nodelist
        fi

        #
        # Exec start on each node
        #
#msg_severity=6 ; msg_type="ccm_prologue_mark"
#        echo "${CCM_JOBID} `/bin/date +%c`" 2>&1 | logmsg
        $xtxqtcmd_path $ccm_init_nodelist "$udiRootSetupPath/sbin/unsetupRoot.sh" >> $ccm_init_log 2>&1
        okcnt=`grep "y (complete)" $ccm_init_log | wc -l`

#        CCM_PATH=/var/crayccm

#	$xtxqtcmd_path $ccm_init_nodelist "mkdir -p  $DSL/$CCM_PATH; echo \"`cat $job_nodelist`\" > $CCM_PATH/ccm_nodelist; echo \"`cat $rhosts_nodelist`\" > $CCM_PATH/ccm_rhosts;  echo \"`su $CCM_USER -c \"cat $CCM_HOMEDIR/.ssh/id_rsa.pub\"`\" > $CCM_PATH/id_rsa.pub;  echo \"`su $CCM_USER -c \"cat $CCM_HOMEDIR/.ssh/id_dsa.pub\"`\" > $CCM_PATH/id_dsa.pub;  $DSL/$ccm_init_path $CCM_USER $CCM_HOMEDIR $CCM_UID $CCM_JOBID $DSL start" >> $ccm_init_log 2>&1

#        echo "`/bin/date +%c`" >> $ccm_init_log 2>&1 

#        msg_severity=6 ; msg_type="ccm_prologue_node"
#        cat $ccm_init_log 2>&1 | logmsg

#        okcnt=`grep "y (complete)" $ccm_init_log|grep "exit code: 0$"|wc -l`
        expcnt=`cat $ccm_init_nodelist | wc -l`

        # store count of nodes in this job
        echo $expcnt > $ccm_rundir/$CCM_USER/$CCM_JOBID.run

        if [ "$expcnt" == "$okcnt" ]; then
                echo UdiRoot Stop success, $okcnt of $expcnt responses
#rm -f $ccm_init_log
                exit_code=0
        else
                echo UdiRoot Stop failed, $okcnt of $expcnt responses
                echo Log on $ccm_init_log
                chmod 644 $ccm_init_log
                exit_code=1
        fi

        rm -f $ccm_init_nodelist

exit $exit_code
